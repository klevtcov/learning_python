''' Графы. Поиск в ширину BFS - Breadth First Search'''

# Поиск в ширину позволяет найти кратчайшее расстояние между двумя объектами
# Алгоритм поиска кратчайшего пути называется поиском в ширину

# Граф моделирует набор связей. Состоит из узлов и рёбер
# Узлы имеющие связь - соседи

# 1. существует ли путь от узла А к узлу Б?
# 2. как выглядит кратчайший путь от узла А к узлу Б,

# 1. Опрашиваем все соседние узлы, являются ли они Б, если нет - опрашиваем все их связи, если нет - связи связей и т.д.

# Очередь - FiFo, Стек - LiFo

#  построение графов
graph = {}
graph['you'] = ['alice', 'bob', 'claire']
graph['bob'] = ['anuj', 'peggy']
graph['alice'] = ['peggy']
graph['claire'] = ['thom', 'jonny']
graph['anuj'] = []
graph['peggy'] = []
graph['thom'] = []
graph['jonny'] = []
# Направленный граф - отношения действуют только в одну сторону

# deque - функция создания двухсторонней очереди (дека)
from collections import deque

def person_is_seller(name):
        return name[-1] == 'm' # возвращает True, если имя заканчивается на 'm'

def search(name):
    search_queue = deque() # создание новой очереди
    search_queue += graph[name] # все соседи добавляются в очередь поиска
    searched = [] # для отслеживания уже проверенных людей
        
    while search_queue: # пока очередь не пуста
        person = search_queue.popleft() # из очереди извлекается первый человек
        if not person in searched: # если не проверялся раньше
            if person_is_seller(person): # проверяем, является ли человек продавцом
                print(person + ' is a mango seller!') # да, является продавцом
                return True
            else:
                search_queue += graph[person]
                searched.append(person) # помечаем как проверенного
    return False

search('you')


# Время выполнения:
# Добавление человека в очередб - О(1)
# Проход по каждому человеку О(количества людей)
# Итого поиск в ширину - О(количество людей + количество рёбер)
# Поиск в ширину - O(V+E),  V - количество вершил, E - количество рёбер

# Если задача А зависит от задачи Б, то задача А находится в более поздней позиции списка
# Такая сортировка называется - Топологической
# т.е.это способ построения упорядоченного списка на основе графа

# Графы, в которых рёбра указывают в одном направлении - деревья

